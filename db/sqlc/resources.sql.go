// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: resources.sql

package db

import (
	"context"
)

const createResource = `-- name: CreateResource :one
INSERT INTO resources (
    material_id,
    title,
    type,
    content_url
) VALUES (
    $1, $2, $3, $4
) RETURNING resource_id, material_id, title, type, content_url, created_at, files
`

type CreateResourceParams struct {
	MaterialID int64        `json:"material_id"`
	Title      string       `json:"title"`
	Type       TypeResource `json:"type"`
	ContentUrl string       `json:"content_url"`
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (Resource, error) {
	row := q.queryRow(ctx, q.createResourceStmt, createResource,
		arg.MaterialID,
		arg.Title,
		arg.Type,
		arg.ContentUrl,
	)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.MaterialID,
		&i.Title,
		&i.Type,
		&i.ContentUrl,
		&i.CreatedAt,
		&i.Files,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM resources
WHERE resource_id = $1
`

func (q *Queries) DeleteResource(ctx context.Context, resourceID int64) error {
	_, err := q.exec(ctx, q.deleteResourceStmt, deleteResource, resourceID)
	return err
}

const getResource = `-- name: GetResource :one
SELECT resource_id, material_id, title, type, content_url, created_at, files FROM resources
WHERE resource_id = $1
`

func (q *Queries) GetResource(ctx context.Context, resourceID int64) (Resource, error) {
	row := q.queryRow(ctx, q.getResourceStmt, getResource, resourceID)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.MaterialID,
		&i.Title,
		&i.Type,
		&i.ContentUrl,
		&i.CreatedAt,
		&i.Files,
	)
	return i, err
}

const listResource = `-- name: ListResource :many
SELECT resource_id, material_id, title, type, content_url, created_at, files FROM resources
WHERE material_id = $1 AND resource_id = $2
ORDER BY resource_id
LIMIT $3
OFFSET $4
`

type ListResourceParams struct {
	MaterialID int64 `json:"material_id"`
	ResourceID int64 `json:"resource_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListResource(ctx context.Context, arg ListResourceParams) ([]Resource, error) {
	rows, err := q.query(ctx, q.listResourceStmt, listResource,
		arg.MaterialID,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ResourceID,
			&i.MaterialID,
			&i.Title,
			&i.Type,
			&i.ContentUrl,
			&i.CreatedAt,
			&i.Files,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResource = `-- name: UpdateResource :one
UPDATE resources
SET title = $3, type = $4, content_url = $5, files = $6
WHERE material_id = $1 AND resource_id = $2
RETURNING resource_id, material_id, title, type, content_url, created_at, files
`

type UpdateResourceParams struct {
	MaterialID int64        `json:"material_id"`
	ResourceID int64        `json:"resource_id"`
	Title      string       `json:"title"`
	Type       TypeResource `json:"type"`
	ContentUrl string       `json:"content_url"`
	Files      []byte       `json:"files"`
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) (Resource, error) {
	row := q.queryRow(ctx, q.updateResourceStmt, updateResource,
		arg.MaterialID,
		arg.ResourceID,
		arg.Title,
		arg.Type,
		arg.ContentUrl,
		arg.Files,
	)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.MaterialID,
		&i.Title,
		&i.Type,
		&i.ContentUrl,
		&i.CreatedAt,
		&i.Files,
	)
	return i, err
}
